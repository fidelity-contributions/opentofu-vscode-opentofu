---
name: Prepare Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      ls_version:
        description: 'New `tofu-ls` version (optional) - "latest" or a specific version (without v prefix)'
        required: false
        type: string

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Get latest release tag
        id: latest_release
        run: |
          latest_tag=$(gh release view --json tagName | jq -r '.tagName')
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Get LS versions and check if `langServer.version` needs update
        id: ls_version
        run: |
          # Version of tofu-ls
          current_ls_version=$(jq -r '.langServer.version' package.json)

          # Latest tofu-ls version
          latest_ls_version=$(gh release view -R opentofu/tofu-ls --json tagName | jq -r '.tagName')

          # Check if we need to update the language server version and set it in output
          # We are updating ls version if specified non-empty version.
          ls_version="${{ inputs.ls_version }}"
          # Flag to indicate this workflow will need to update the ls version
          updates_ls_version=false
          if [ "$ls_version" != "" ]; then
            # If specified version is 'latest' and the current version is the latest, we don't update the version.
            if [ "$ls_version" == "latest" ] && [ "$current_ls_version" == "$latest_ls_version" ]; then
              ls_version=$latest_ls_version
            else
              if [ "$ls_version" == "latest" ]; then
                ls_version=$latest_ls_version
              fi
              # $ls_version in this case is already set from input
              updates_ls_version=true
              echo "ls_version_changed=true" >> $GITHUB_OUTPUT
            fi
          else
            ls_version=$current_ls_version
          fi

          # Even if the ls version wasn't set during the workflow run it still can be different from the one in the last release of the extension
          # We can check if that is the case
          if [[ $updates_ls_version == false ]]; then
            # We can get the langServer set in the last release using `git show` and latest tag we obtained in the last step
            previous_version=$(git show ${{ steps.latest_release.outputs.latest_tag }}:package.json | jq -r '.langServer.version')
            # We add a new flag to indicate the case, when tofu-ls version changed but not necessarily by the workflow and we can prepend it in release notes
            if [[ "$previous_version" != "$current_ls_version" ]]; then
              echo "ls_version_changed=true" >> $GITHUB_OUTPUT
            fi
          fi

          # This output indicates what the ls version will be after it is updated in the next step
          # Hence, it is set to the current version if no update occurs
          echo "ls_version=$ls_version" >> $GITHUB_OUTPUT
          echo "updates_ls_version=$updates_ls_version" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current version and update it to the next one
        id: version
        run: |
          # Get current version of the extension
          current_version=$(jq -r '.version' package.json)
          echo "current_version=$current_version" >> $GITHUB_OUTPUT

          # Calculate next version using `npm version` command. The `next_version` includes the 'v' prefix
          next_version=$(npm version "${{ inputs.version_bump }}" --no-git-tag-version)
          echo "next_version=$next_version" >> $GITHUB_OUTPUT
          echo "branch_name=release/$next_version" >> $GITHUB_OUTPUT

      - name: Update `tofu-ls` version
        if: ${{ steps.ls_version.outputs.updates_ls_version }}
        run: |
          jq '.langServer.version = "${{ steps.ls_version.outputs.ls_version }}"' package.json > package_temp.json
          mv package_temp.json package.json

      - name: Configure bot and Create a release branch
        run: |
          git config user.name "OpenTofu Maintainers [bot]"
          git config user.email "maintainers@opentofu.org"
          git checkout -b ${{ steps.version.outputs.branch_name }}

      - name: Generate release notes
        id: release_notes
        run: |
          # Use GitHub API to generate release notes
          response=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -X POST \
            "https://api.github.com/repos/${{ github.repository }}/releases/generate-notes" \
            -d '{
              "tag_name": "${{ steps.version.outputs.next_version }}",
              "target_commitish": "${{ github.ref_name }}",
              "configuration_file_path": ".github/release-notes.yml",
              "previous_tag_name": "${{ steps.latest_release.outputs.latest_tag }}"
            }')
            # Extract the body from the response and append to summary
            release_notes=$(echo "$response" | jq -r '.body')
            # Remove a line starting with "## What's Changed" and a comment from notes
            release_notes=$(echo "$release_notes" | sed "/^## What's Changed/d" | sed "/^<!--.*-->/d")
            # If we updated the ls version, we need to insert that note at the start.
            # This checks version change by the workflow and difference from the last version
            if [[ "${{ steps.ls_version.outputs.ls_version_changed }}" = "true" ]]; then
              release_notes="*Includes a new LS version - [tofu-ls ${{steps.ls_version.outputs.ls_version}}](https://github.com/opentofu/tofu-ls/releases/tag/v${{ steps.ls_version.outputs.ls_version }})*
              ${release_notes}"
            fi
            # To avoid errors due to multiline notes strings, we encode and decode it in base 64
            encoded_release_notes=$(echo "$release_notes" | base64 --wrap=0)
            echo "release_notes=$encoded_release_notes" >> $GITHUB_OUTPUT
            echo "$release_notes" >> $GITHUB_STEP_SUMMARY

      - name: Create version changelog file and Update CHANGELOG.md
        id: changelog_entry
        run: |
          # Get the current date
          current_date=$(date +"%Y-%m-%d")

          # Create changelog file in .changes
          release_file=".changes/${{ steps.version.outputs.next_version }}.md"
          decoded_release_notes=$(echo "${{steps.release_notes.outputs.release_notes}}" | base64 --decode)
          {
            echo "## ${{ steps.version.outputs.next_version }} ($current_date)"
            echo ""
            echo "$decoded_release_notes"
          } > $release_file

          # Create new changelog entry
          # Here we retain the header (# Changelog) and appending the whole content of the $release_file
          {
            echo "# Changelog"
            echo ""
            cat "$release_file"
            echo ""
            # Add the rest of the existing changelog (skip the header)
            tail -n +2 CHANGELOG.md
          } > CHANGELOG_new.md

          mv CHANGELOG_new.md CHANGELOG.md
          echo "release_file=$release_file" >> $GITHUB_OUTPUT

      - name: Commit changes
        run: |
          git add package.json package-lock.json CHANGELOG.md "${{ steps.changelog_entry.outputs.release_file }}"
          git commit -s -m "chore: prepare release ${{ steps.version.outputs.next_version }}"
          git push origin ${{ steps.version.outputs.branch_name }}

      - name: Create Pull Request
        run: |
          # Draft is needed to allow the PR to trigger the run checks after someone puts the PR as "Ready To Review"
          gh pr create \
            --label "release" \
            --draft \
            --title "Release ${{ steps.version.outputs.next_version }}" \
            --body "$(cat <<EOF
          ## Release ${{ steps.version.outputs.next_version }}

          This PR prepares the automated release for version ${{ steps.version.outputs.next_version }}.
          This PR is safe to modify.

          ### Changes:
          - Updated version from ${{ steps.version.outputs.current_version }} to ${{ steps.version.outputs.next_version }}
          $(if [ -n "${{ steps.ls_version.outputs.updates_ls_version }}" ]; then echo "- Updated `tofu-ls` version to ${{ inputs.ls_version }}"; fi)
          - Added changelog for the new version and a new entry in CHANGELOG.md with auto-generated release notes

          ### Generated Release Notes:
          $(cat "${{ steps.changelog_entry.outputs.release_file }}")
          EOF
          )" \
            --head ${{ steps.version.outputs.branch_name }} \
            --base ${{ github.ref_name }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Output summary
        run: |
          echo "## Release" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Current Version:** ${{ steps.version.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Next Version:** ${{ steps.version.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Branch:** ${{ steps.version.outputs.branch_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "A pull request has been created with all the necessary changes." >> $GITHUB_STEP_SUMMARY
          echo "Review and merge the PR to trigger the release." >> $GITHUB_STEP_SUMMARY
